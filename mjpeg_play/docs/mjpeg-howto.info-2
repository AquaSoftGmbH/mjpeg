Dies ist mjpeg-howto.info, hergestellt von Makeinfo Version 4.5 aus
/tmp/linuxdoc-dir-3370/sgmltmp.mjpeg-howto.info.2.

   \input texinfo


File: mjpeg-howto.info,  Node: MPEG1 Multiplexing Example,  Prev: MPEG1 Video creation Example,  Up: Creating MPEG1 Videos

MPEG1 Multiplexing Example
--------------------------

   Example

   ` >mplex sound.mp2 video.m1v -o my_video.mpg'

   Puts the sound.mp2 and the video.m1v stream together to my_video.mpg.
It only works that easy if you have CBR (the -q option was not used with
mpeg2enc).

   Example

   `mplex -V -r 1740 audio.mp2 video_vbr.m1v -o vbr_stream.mpg'

   Here we multiplex a variable bitrate stream. mplex is now a single
pass multiplexer so it can't detect the maximal bitrate and we have to
specify it. The data rate for the output stream is: `audio bitrate +
peak videobitrate + 1-2% for mplex information'. If audio (-b 224) has
224kBit, video has 1500kBit (was encoded with -b 1500 -q 9) then we
have 1724 * 1.01 or about 1740kBit.


File: mjpeg-howto.info,  Node: Creating MPEG2 Videos,  Next: Creating Video-CD's,  Prev: Creating MPEG1 Videos,  Up: Converting the stream to MPEG or DIVx videos

Creating MPEG2 Videos
=====================

   MPEG2 is recommended for sources with a greater picture than 352x240
for NTSC and 352x288 for PAL. MPEG2 can also handle interlaced sources
like recording from TV at full resolution.

   MPEG2 allows the usage of mpeg layer 3 (mp3) sound. So you can use
your favorite mp3encoder for the creation of the sound.  However, MP3
audio is not valid for DVDs.  It is best to use MP2 (Layer 2) audio.
The audio can also be a VBR Stream.

   MPEG2 is usually a VBR Stream. MPEG2 creation with optimization
requires a lot of CPU power.  A film with the double resolution is NOT
4 times larger than an MPEG1 Stream. Depending on your quality settings
it will be about 1.5 up to 3 times larger than the MPEG1 Stream at its
lower resolution.

* Menu:

* MPEG2 Audio creation Example::
* MPEG2 Video creation Example::
* MPEG2 Multiplexing Example::


File: mjpeg-howto.info,  Node: MPEG2 Audio creation Example,  Next: MPEG2 Video creation Example,  Up: Creating MPEG2 Videos

MPEG2 Audio creation Example
----------------------------

   `> lav2wav editlist.eli | mp2enc -o sound.mp2'

   This will fit the MPEG2 quite well. You can save some bits by telling
mp2enc to use a lower bitrate (-b option) like 160 or 192 kBit/s.  I
hope I don't need to explain the usage of an MP3 Encoder ?  But you
should not use all the fancy options that are available.


File: mjpeg-howto.info,  Node: MPEG2 Video creation Example,  Next: MPEG2 Multiplexing Example,  Prev: MPEG2 Audio creation Example,  Up: Creating MPEG2 Videos

MPEG2 Video creation Example
----------------------------

   `> lav2yuv editlist.eli | mpeg2enc -f 3 -b 3000 -q 9 -o video.m2v'

   A very simple example for MPEG2 Video.  The most important option is
the -f 3. That tells mpeg2enc that it should create a MPEG2 stream.
Because it is a generic MPEG2 you have to use the -b bitrate options.
And should use the -q option because you usually want a space saving
VBR Stream. When using VBR streams the -b option tells mpeg2enc the
maximum bitrate that can be used. The -q option tell mpeg2enc what
quality the streams should have.  The bitrate has an upper bound of the
value specified by -b.

   `> lav2yuv editlist.eli | mpeg2enc -f 3 -4 1 -2 1 -q7 -b 4500 -V 300
-P -g 6 -G 18 -I 1 -o video.m2v'

   This will generate a higher quality MPEG2 stream because the -4 1 and
-2 1 options were used.  With -b 4500 -q 7 you tell mpeg2enc the
maximal bitrate and the quality factor.  -V is the video buffer size
used for decoding the stream. For SW playback it can be much higher
than the default. Dynamic GOP is set with -g and -G.  A larger GOP size
can help reduce the bit-rate required for a given quality. The -P option
also ensures that 2 B frames appear between adjacent I/P frames. The -I
1 option tells mpeg2enc that the source is a interlaced material like
videos. There is (time consuming) interlaced motion compensation logic
present in mpeg2enc.  Mpeg2enc will use that logic if the size of the
frames you encode is larger than the VCD size for your TV Norm.

   If you denoise the images with yuvdenoise and use the deinterlacing
(-F) option you should tell mpeg2enc that it does not need to do motion
estimation for interlaced material. You have to use the -I 0 -I 0
option of mpeg2enc to say that the frames are already deinterlaced.
This will save a lot of time when encoding. If you don't use -I 0 it
will not cause problems, the encoding will just take longer.

   You can also use scaling an options that optimize (denoise) the
images to get smaller streams.  These options are explained in detail
in the following sections.

* Menu:

* Which values should be used for VBR Encoding::
* Encoding destination TV (interlaced) or Monitor (progressive)::


File: mjpeg-howto.info,  Node: Which values should be used for VBR Encoding,  Next: Encoding destination TV (interlaced) or Monitor (progressive),  Up: MPEG2 Video creation Example

Which values should be used for VBR Encoding
............................................

   The -q option controls the minimum quantization of the output stream.
Quantization controls the precision with which image information is
encoded. The lower the value the better the image quality.  Values
below 4 are extremes and should only be used if you know what you are
doing

   Usually you have to set up a maximum bitrate with the -b option.
The tricky task is to set a value for the -q option and the -b option
that produces a nice movie without using too much bandwidth and does not
introduce too many artifacts.

   A quality factor should be chosen that way that the mplex output of
Peak bit-rate and average bit-rate differ by about 20-25%.  If the
difference is very small < 10%, it is very likely that you have done
something wrong. It is very likely that you have chosen the wrong
values for the maximal bitrate or a quality factor that is too high.

   A combination that will produce more artifacts than you can count is
a SVCD with a maximal video bitrate of 2500kBit and a qualitfactor set
to 1 or 2.  For SVCD with a video limit of 2500kBit a quality factor of
7-11 fits quite good (8 is the default). If you use filter programs or
have a very good source like digital TV, DVD like material or rendered
pictures you can use a quality factor of 6 when creating SVCDs.  If
your SVCD/DVD player supports higher bitrates than the official
2788kBit/sec for the video and audio.   When using a higher bitrate and
quality factor action scenes will look much better.

   The same (7-11) quality factor for a full size picture and a top
bitrate of 3500 to 4000 kBit will produce few artifacts.

   For SVCD/DVD you can expect a result like the one described if the
maximal bitrate is not set too low:

   q <= 6 real sharp pictures, and good quality    q <= 8 good quality
 q >= 10 average quality    q >= 11 not that good    q >= 13 here even
still sequences might look blocky


File: mjpeg-howto.info,  Node: Encoding destination TV (interlaced) or Monitor (progressive),  Prev: Which values should be used for VBR Encoding,  Up: MPEG2 Video creation Example

Encoding destination TV (interlaced) or Monitor (progressive)
.............................................................

   MPEG2 supports interlaced data in addition to the progressive format.
A MPEG2 movie can be interlaced or progressive. It depends on the source
(film or broadcast) and on the viewing device.

   If you encode a film both fields should be the same. Deinterlace the
stream with yuvdenoise -F, or if you have a high quality source, and
don't need to use the denoiser, with yuvcorrect -T NOT_INTERLACED. Also
set the mpeg2enc interlace-mode (-I) option to 0. This means that there
is no interlacing.  We do not really need deinterlacing here because
there is no motion between the fields of the frame. We only need to
unite the two fields into a single progressive frame.

   This movie should play back an any device (TV or Monitor) without
problems.

   If you have an interlaced source (broadcast) you can encode it as
interlaced stream. Or deinterlace the stream and encode it as
progressive stream. If you deinterlace it with yuvdenoise -F, you will
lose details.  But if you plan to play the recorded stream on your DVD
player and your TV it would not be wise to do that.  If you only want
to play it back on the Monitor (progressive display) the picture looks
better when playing it back if it is deinterlaced. If the player you
use can do deinterlacing it does not matter if your encoded video has
interlaced frames or progressive frames.

   If you plan to deinterlace the stream you can only do this with
yuvdenoise -F, and set the mpeg2enc -I 0. If you do not want to
deinterlace the stream you do not need to set any special option (do
not use yuvdenoise -F and mpeg2enc -I 0)

   If you like to pause the stream and look on the still you should
deinterlace. Because then the image is flicker free when pausing.

   If you have a film (progressive) with parts from a broadcast
(interlaced) mixed together (like in a documentary where some parts
from a speaker are recorded interlaced and other parts are filmed) you
have to choose between good film sequences with average still images or
average looking film sequences with good still images.

   For good film with average stills do not deinterlace.  For average
film sequences with good stills then deinterlace (using -F and -I 0).


File: mjpeg-howto.info,  Node: MPEG2 Multiplexing Example,  Prev: MPEG2 Video creation Example,  Up: Creating MPEG2 Videos

MPEG2 Multiplexing Example
--------------------------

   `> mplex -f 3 -b 300 -r 4750 -V audio.mp3 video.mp3 -o final.mpg'

   Now both streams (a mp3 audio and a mpeg2 video) are multiplex into a
single stream (final.mpg). You have to use the -f 3 option to tell
mplex the output format. You also have to add the -b decoder buffers
size with the same value used when encoding the video. -r is that rate
of video + audio +1-2% of mplex information.

   The -V option tells that your source for mplexing is a VBR stream. If
you don't use this option mplex creates something like a CBR Stream
with the bitrate you have told it with the -r option.  These streams
are usually get BIG.


File: mjpeg-howto.info,  Node: Creating Video-CD's,  Next: Creating SVCD,  Prev: Creating MPEG2 Videos,  Up: Converting the stream to MPEG or DIVx videos

Creating Video-CD's
===================

   VCD is a cut down version of MEPG1 streams.  VCD format was defined
by Philips. The goal was to use a single speed CD-drive and other cheap
hardware (not flexible) to have a cheap HW-Player.  Because of that
there are some limitations on VCD's.  The bitrate for video is 1152kBit
and for audio layer 2 audio 224kBit stereo.  You are not allowed to use
the -q option, dynamic GOP sizes and the video buffer is limited to
46kB.  The image size is limited to 352x240 for NTSC, an to 352x288 for
PAL.

   If you have no VCD (only) player and you plan to use your DVD player
then it is quite possible that the DVD player will be flexible enough
to allow higher bitrates, dynamic GOP sizes, larger video buffer and so
on

* Menu:

* VCD Audio creation Example::
* VCD Video creation Example::
* VCD Multiplexing Example::
* Creating the CD::
* Notes::
* Storing MPEGs::


File: mjpeg-howto.info,  Node: VCD Audio creation Example,  Next: VCD Video creation Example,  Up: Creating Video-CD's

VCD Audio creation Example
--------------------------

   `> lav2wav stream.avi | mp2enc -V -o sound.mp2'

   `-V' force VCD compatible output (same as: -b 224 -r 44100 -s). For
hardware players, you should stick to 44.1 224kBps Stereo layer 2 Audio.


File: mjpeg-howto.info,  Node: VCD Video creation Example,  Next: VCD Multiplexing Example,  Prev: VCD Audio creation Example,  Up: Creating Video-CD's

VCD Video creation Example
--------------------------

   `> lav2yuv stream.avi | yuvscaler -O VCD | mpeg2enc -f 1 -r 16 -o
video.mpg'

   For a VCD compatible output the -f 1 sets all options in mpeg2enc as
needed. It seems that many VCD players (Avex for example) are not able
to play MPEG streams that are encoded with a search radius greater than
16 so do not use the -r option to override the default of 16.

   `> lav2yuv streams.eli | mpeg2enc -f 1 -4 1 -2 1 -S 630 -B 260 -P -o
video.m1v'

   Using `'-S 630" means that mpeg2enc marks the stream so that mplex
generates a new stream every 630MB. One important thing is the use of
the `-B' option which specifies the non-video (audio and mplex
information) bitrate. The -B value of 260 should be fine for audio with
224kBit and mplex information. For further information take a look at
the encoding scripts in the scripts directory. So the multiplexed
streams should easily fit on a CD with 650MB.

   The default value (-B) is 700MB for the video. mpeg2enc marks
automatically every stream at that size if the -B option is not used to
set a different value.  If you have a CD where you can write more data
(perhaps as much as 800MB), you have to set the -S option or otherwise
mpeg2enc will mark the stream at 700 MB, and mplex will split the
stream there.  Which is almost certainly not what you want.


File: mjpeg-howto.info,  Node: VCD Multiplexing Example,  Next: Creating the CD,  Prev: VCD Video creation Example,  Up: Creating Video-CD's

VCD Multiplexing Example
------------------------

   `> mplex -f 1 sound.mp2 video.mpg -o vcd_out.mpg'

   The -f 1 option turns on a lot of weird stuff that otherwise has no
place in a respectable multiplexer!


File: mjpeg-howto.info,  Node: Creating the CD,  Next: Notes,  Prev: VCD Multiplexing Example,  Up: Creating Video-CD's

Creating the CD
---------------

   The multiplexed streams have to be converted to an VCD compatible.
This is done by vcdimager http://www.vcdimager.org/

   `> vcdimager testvideo.mpg'

   Creates a `videocd.bin', the data file, and a `videocd.cue' which is
used as control file for cdrdao.

   You use cdrdao to burn the image. Cdrdao is yet another fine
Sourceforge project which is found at: http://cdrdao.sourceforge.net/


File: mjpeg-howto.info,  Node: Notes,  Next: Storing MPEGs,  Prev: Creating the CD,  Up: Creating Video-CD's

Notes
-----

   For MPEG-1 encoding a typical (45 minute running time) show or 90 odd
minute movie from an analog broadcast a constant bit-rate of around
1800 kBit/sec should be ideal. The resulting files are around 700M for
45 minutes which fits nicely as a raw XA MODE2 data track on a CD-R.
For pure digital sources (DTV or DVD streams and similar) VCD 1152
works fine.

   `Note:' If you encode VBR MPEG1 (-q) remember the Hardware was
probably not designed to do the playback because it is not in the
specifications. If it works be very happy. I've noticed that it helps
when you have an MPEG1 Stream to tell vcdimager that it is an SVCD.
vcdimager complains (but only with a warning and not a fatal error) but
you should be able to burn it. This could convince the player to use
different routines in its firmware and play it back correct, but there
is no guarantee of that.


File: mjpeg-howto.info,  Node: Storing MPEGs,  Prev: Notes,  Up: Creating Video-CD's

Storing MPEGs
-------------

   If you record the data as XA mode 2 tracks you can fit appreciably
more on a CD (at the expense of error correction/detection). You can
use vcdimager to do this and vcdxrip (part of the vcdimager package) to
extract ("rip") the resulting files. For better Quality there are SVCD
and XVCD and DVD.

   Currently SVCD is fully supported with a pre-set format in mplex and
tools to create disks. MPEG streams that can be played by DVD player
hardware and software can readily produced using mpeg2enc/mplex

   If your player doesn't support SVCD you may well find it can handle
VCD streams that have much higher than standard bit-rates. Often as
much as 2500kBit/sec is possible. The AudioVox 1680 for example can
handle 2500kBit/s VCD rates (it also handles VCDs with VBR MPEG-1 but
other players might not be so forgiving).  With higher bit-rates and
good quality source material it is worth trying mpeg2enc's -h flag
which produce a stream that is as sharp as the limits of the VCD
standard permits.

   However, if your player supports it and you have the patience for the
much longer encoding times SVCD is a much better alternative. Using a
more efficient MPEG format SVCD more than doubles VCD's resolution
while typically producing files that are less than twice as big.


File: mjpeg-howto.info,  Node: Creating SVCD,  Next: Creating DVD's,  Prev: Creating Video-CD's,  Up: Converting the stream to MPEG or DIVx videos

Creating SVCD
=============

   SVCD is a cut down version of MPEG2 streams. SVCD format was defined
by Philips.  Super Video CD (SVCD) is an enhancement to Video CD that
was developed by a Chinese government-backed committee of manufacturers
and researchers.  The final SVCD spec was announced in September 1998.

   Record at full TV resolution (means: -d 1 for PAL this is 720x576)
The resolution is for NTSC is 480x480 of PAL 480x576, so you know why
you should record at full size.

* Menu:

* SVCD Audio creation Example::
* SVCD Video creation Example::
* SVCD Multiplexing Example::
* SVCD Creating the CD::


File: mjpeg-howto.info,  Node: SVCD Audio creation Example,  Next: SVCD Video creation Example,  Up: Creating SVCD

SVCD Audio creation Example
---------------------------

   `> lav2wav stream.avi | mp2enc -V -o sound.mp2'

   The SVCD specifications permit a much wider choice of audio rates,
it is not necessary to use 224 kBit/sec. Any audio rate between 32 and
384 kBit/sec is permitted. The audio may be VBR (Variable Bit Rate).


File: mjpeg-howto.info,  Node: SVCD Video creation Example,  Next: SVCD Multiplexing Example,  Prev: SVCD Audio creation Example,  Up: Creating SVCD

SVCD Video creation Example
---------------------------

   `> lav2yuv stream.avi | yuvscaler -O SVCD | mpeg2enc -f 4 -q 7 -I 1
-V 200 -o video.m2v'

`-f 4'
     sets the options for mpeg2enc to SVCD

`-q 7'
     tell mpeg2enc to generate a variable bitrate stream

`-I 1'
     tell mpeg2enc to assume that the original signal is field
     interlaced video where the odd rows of pixels are sampled a half
     frame interval after the even ones in each frame. The -I 0
     (progressive output (no field pictures)) option will also work for
     PAL


   You can use lower bitrates, but the SVCD standard limits `total
bit-rate (audio and video) to 2788800 Bit/sec'. So with 224Kbps audio
and overhead 2550 may already be marginally too tight. Since the SVCD
format permits any audio rate between 32 and 224 kBit/sec you can save
a few bits/sec by using 192k audio (or for non-musical material 160k).

   SVCD supports variable bitrate (VBR), because MPEG2 is usually VBR,
but with the top video bitrate limit of 2500kBit/sec. With the -f 4
flag the encoder also sets dynamic GOP with a low limit of -g 6 and a
high limit of -G 18. This saves a few bits/sec and improves the picture
quality during scene changes.  When encoding with -f 4 mpeg2enc ignores
the video bitrate (-b) and search radius (-r) options. If you use -f 5
mpeg2enc uses this options.

   An other possibility for movies in PAL (European style 25 frames/50
fields per sec) video is:

   `> lav2yuv stream.avi | yuvscaler -O SVCD | mpeg2enc -f 4 -I 0 -V
300 -o video.m2v'

   Movies are shot on film at 24 frames/sec. For PAL broadcast the film
is simply shown slightly "too fast" at 25 frame/sec (much to the pain
of people with an absolute pitch sense of pitch). The -I 0 flag turns
off the tedious calculations needed to compensate for field interlacing
giving much faster encoding.

   Unfortunately, movies broadcast in NTSC (US style 30 frames/60 fields
sec) video this will produce very poor compression. The "pulldown"
sampling used to produce 60 fields a second from a 24 frame a second
movie means half the frames in an NTSC *are* field interlaced.

   Don't forget the -S and -B options mentioned above. You want that the
stream fits on the CD don't you ?


File: mjpeg-howto.info,  Node: SVCD Multiplexing Example,  Next: SVCD Creating the CD,  Prev: SVCD Video creation Example,  Up: Creating SVCD

SVCD Multiplexing Example
-------------------------

   `> mplex -f 4 -b 300 -r 2750 sound.mp2 video.m2v -o svcd_out.mpg'

`-f 4'
     tells mplex to mplex a SVCD

`-r 2750'
     is the calculated Audio + Video Bitrate + 1-2% multiplex
     information

`-b 300'
     is the buffer available on the playback device (the same value as
     used for the video encoding (mpeg2enc's -V option).



File: mjpeg-howto.info,  Node: SVCD Creating the CD,  Prev: SVCD Multiplexing Example,  Up: Creating SVCD

SVCD Creating the CD
--------------------

   Example:

   `> vcdimager -t svcd testvideo.mpg'

   Creates a `videocd.bin', the data file, and a `videocd.cue' which is
used as control file for cdrdao.

   Use cdrdao to burn the image as mentioned earlier.

   `NOTE:'If you want to build "custom" VCD/SVCD you will need to use
the mplex -f 2 and -f 5 switches.

   `NOTE:'The VCD and SVCD stuff may work on your HW player or not.
There are many reports that it works quite well. Don't be worried if it
does not work. Nor am I responsible for unusable CDs. ("coasters")


File: mjpeg-howto.info,  Node: Creating DVD's,  Next: Creating DIVX Videos,  Prev: Creating SVCD,  Up: Converting the stream to MPEG or DIVx videos

Creating DVD's
==============

   Everything in this section is very new. So it can change every day.
The limitations I mention here might not exist in the current version.

   You need obviously a DVD writer. I own a Ricoh DVD+RW that works,
and I know of a DVD-RAM writer that is able to to burn DVD-R. That
disks also work with a DVD-Player. Which programs you use for burning
depends on the DVD writer drive.

   For the creation and writing of the VOB, IFO and BUP files we use
dvdauthor. Aviable from Sourceforge (you might have guessed it)
http://dvdauthor.sourceforge.net.

* Menu:

* DVD Audio creation Example::
* DVD Video creation Example::
* DVD Mplex Example::
* DVD creation Example::


File: mjpeg-howto.info,  Node: DVD Audio creation Example,  Next: DVD Video creation Example,  Up: Creating DVD's

DVD Audio creation Example
--------------------------

   `> lav2way stream.eli | mp2enc -r 48000 -o sound.mp2'

`-r 48000'
     The sample rate has to be 48kHz. The mp2enc -r option forces the
     sample rate to 48kHz. If it is not a 48kHz mp2enc will resample
     the audio to get the sample rate.  If the audio is recorded at
     48kHz then no resampling is needed and toolame can be used for the
     encoding (it is much faster than mp2enc).



File: mjpeg-howto.info,  Node: DVD Video creation Example,  Next: DVD Mplex Example,  Prev: DVD Audio creation Example,  Up: Creating DVD's

DVD Video creation Example
--------------------------

   `> lav2yuv stream.eli | mpeg2enc -f 8 -o video.m2v'

`-f 8'
     This sets the options correctly for a MPEG-2 video that is
     compliant with the DVD standard.  The maximum bitrate is set to
     7500kBps and the video buffer size is set to 230KB. The default
     quality factor is set to 8.  mpeg2enc sets currenty no automatic
     sequence length as it does for VCD/SVCD.


   The other options to get a low bitrate and high quality stream can
also be used to override the default settings mentioned above.  You can
also use yuvdenoise to increase the picture quality.  A typical command
will look like this:

   `lav2yuv moby.eli | yuvdenoise -F -f | mpeg2enc -f 8 -q 7 -4 1 -2 1
-P -I 0 -N -o video_DVD.m2v'


File: mjpeg-howto.info,  Node: DVD Mplex Example,  Next: DVD creation Example,  Prev: DVD Video creation Example,  Up: Creating DVD's

DVD Mplex Example
-----------------

   `> mplex -f 8 sound.mp2 video.m2v -o my_dvdlikestream.mpg'

`-f 8'
     Here again we specify that we want to have DVD like MPEG stream.
     mplex cannot do all the fancy things allowed for a DVD, but it is
     close enough that the HW-DVD players accept it.

`-o'
     there we specify the output filename.



File: mjpeg-howto.info,  Node: DVD creation Example,  Prev: DVD Mplex Example,  Up: Creating DVD's

DVD creation Example
--------------------

   This topic will be covered by the documentation of the dvdauthor
program.  For questions please see dvdauthor In general it will work
like this:

   `> makedvd stream1.mpg stream2.mpg ... my_dvdlikestream.mpg'

   You will get a directory with AUDIO_TS and VIDEO_TS directories.
Burning the data from the disk to a DVD+R/+RW writer would be done like
this:

   `growisofs -Z /dev/scd2 -dvd-video mydvd/'

   If you own a DVD+RW/+R drive a good place for more information is:
DVD+RW/+R for Linux page. You also need a version of the cdrtools with
`dvd-video' support.  The cdrtools 1.11a27 is known to work but newer
versions already exist.

   For other writers the commands to write a DVD will be different. You
can get some more information in the dvdauthor package. There is no
guarantee that it will work at all !!!


File: mjpeg-howto.info,  Node: Creating DIVX Videos,  Prev: Creating DVD's,  Up: Converting the stream to MPEG or DIVx videos

Creating DIVX Videos
====================

* Menu:

* lav2avi-sh::


File: mjpeg-howto.info,  Node: lav2avi-sh,  Up: Creating DIVX Videos

lav2avi-sh
----------

   A other version of creating DIVX is the program `mencoder' which is
part of mplayer suit http://www.mplayer.hu/.  The script should be self
explanatory. For more information about mencoder please read
mencoder/mplayer help and docu. A first and a second pass give at the
end of pass hints for bitrate, which can be used for encoding to
specific size (650 MB, 700 MB and 800 MB). The script lav2avi.sh is
using this information, if provided because for short streams is
ommited by mencoder.  Look for parameter `preferedSize' in the script.
You can also specify other parameters used for encoding with
`encoderParam' option in the script. For a description of the usable
parameters take a look in the mplayer/mencoder manual.

   The outputfilename is that name of your input file (first option)
but with the extension avi. If the size of file is less then specified
by `preferedSize' it's because here was too less information for
encoding. You usually get 700MB for 1.5 hour film at half image size
with bitrate around 900 that means for divx very good quality.

   The script does a 3 step encoding:

   * 1st step - audio encoding

   * 2nd step - first video pass

   * 3rd step - second video pass

   For encoding the fast ffmpeg codec (compilation switch of mencoder).
It gives nice results together with good performance. For audio
encoding mp3 is used. For encoding of all parts is uses unix pipes.
This mean that you DO NOT need additional space on your hard drive
where all glav manipulations will be done. For audio encoding the
script uses a FIFO queue.

   If you want to tweak the script for your own needs, use that hints:
   * Output of 1st step is file called `frameno.avi' with encoded audio

   * 2nd step is using `frameno.avi' and output is text file called
     `lavc_stats.txt' with timing informations

   * 3rd step is using `frameno.avi' and `lavc_stats.txt' for encoding
     the stream to the output file `movie2.avi'

   * If you want change only video bitrate, keep the file `frameno.avi'
     comment out the 1st step encoding and repeate 2nd and 3rd step.
     Dont forget to remove the line where the `frameno.avi' is removed.


File: mjpeg-howto.info,  Node: Optimizing the stream,  Next: Transcoding of existing MPEG-2,  Prev: Converting the stream to MPEG or DIVx videos,  Up: Top

Optimizing the stream
*********************

   Using filters helps to increase the image quality using fixes bitrate
video streams. With VBR (variable bit rate) video the filesize is
reduced.

   Example

   `> lav2yuv stream.avi | yuvmedianfilter | mpeg2enc -o video.m1v'

   Here the yuvmedianfilter program is used to improve the image. This
removes some of low frequence noise in the images. It also softens the
image a little. It takes a center pointer and averages the pixels
around it that fall within the specified threshold. It then replaces
the center pixel with this new value.  You can also use the -r (radius)
option for an other search radius.

   `NOTE:'a radius greater than the default value of 2 is horrendously
slow!

   yuvmedianfilter has separate settings for luma and chroma. You can
control the search radius and the trigger threshold independently.  If
you use a threshold of 0 then filtering is disabled (-t 0 disables luma
filtering, -T 0 disables chroma filtering).

   `> lav2yuv stream.avi | yuvmedianfilter -r 3 -t 4 -T 0 | mpeg2enc -o
video.m1v'

   This example uses a search radius of 3 pixels for the luma, a
threshold of 4 (the default is 2), and disables filtering for the
chroma components.   Sometimes, depending on the source material,
median filtering of the chroma can cause a slight color shift towards
green.   Filtering on the luma component (disabling the chroma
filtering) is the solution to that problem.

   Example

   `> lav2yuv stream.avi | yuvdenoise | mpeg2enc -o video.m1v'

   Now we are using yuvdenoise to improve the image. The filter mainly
reduces color and luminance-noise and flickering due to phase errors
but is also effective at removing speckles.  If you want yuvdenoise to
deinterlace the stream use the -F option.

   By default yuvdenoise denoises interlaced if the input is
interlaced. Like yuvmedianfilter you can also change the denoiser
threshold (-t), you can also use adifferent search raduis (-r). You can
also set a active area where everything outside that area is set to
real black. This might speed up things a little.

   yuvdenoise uses a different approach to filter the noise.  More
information about how yuvdenoise works as well as descriptions of its
options are found in the manpage.

   Example

   `> lav2yuv stream.avi | yuvkineco -F 1 | mpeg2enc -o video.m1v'

   yuvkineco is used for NTSC sources. It does the conversation from
30000.0/1001.0 (about 29.97) fps to 24000.0/1001.0 (about 23.976) fps,
you can call it "reverse 2-3 pulldown" more info about this in the
README.2-3pulldown. yuvkineco does only remove NTSC specific problems.

   If you want to improve the image you should also use yuvdenoise:

   `> lav2yuv stream.avi | yuvkineco | yuvdenoise | mpeg2enc -o
video.m1v'

   Example

   `> lav2yuv stream.avi | yuvycsnoise | mpeg2enc -o video.m1v'

   yuvycsnoise is also used for NTSC and is specialized for NTSC Y/C
separation noise. If video capture hardware has only a poor Y/C
separator then at vertical stripes (especially red/blue) noises appear
which seem checker flag and bright/dark invert per 1 frame.
yuvycsnoise reduces noises of this type. You can also use different
thresholds for luma/chroma and the optimizing method.  This filter is
not needed with working with DV (Digital Video) data.

   yuvycsnoise works only correct when we have NTSC with:

   * full height (480 lines)

   * full motion captured (29.97 fps)

   * captured with poor Y/C separator hardware

   For more information about the yuvkineco and yuvycsnoise read the
README in the yuvfilters directory.

   If you want to experiment to determine the optimal settings for the
denoiser, scaler and so on replace the mpeg2enc or yuv2divx with
yuvplay.  yuvplay plays back the yuv frames so you can see if the
options you have chosen are making the thing better or worse.

   A command would look like this:

   `> lav2yuv stream.eli | yuvdenoise -options | yuvscaler -options |
yuvplay'

   If you are looking for a hardware device that can make the video look
better before you record it we currently know about two firms that
produce such boxes.

   One produced by SIMA: http://www.simacorp.com/scc.htm, that device
will work with NTSC.  And a one other produced by ELV (german
distributor): http://www.elv.de there you find in the SHOP area, a
section where you can take a look at their Video - Audio devices. Most
of the  ELV devices work only with PAL.

   If you want to know how much each tool lowers the average bitrate.
You can use this table to see what you can expect if you have a full
size video and want to create a DVD with a qality factor of 5 and the
allowed maximal bitrate of 8500kb/sec.

   * no denoising : 8300 kb/s (mostly hitting the upper bound)

   * yuvenoise : 7700 kb/s

   * mpeg2enc -reduce-hf : 7400 kb/s

   * yuvdenoise + yuvmedianfilter : 6000 kb/s

   * yuvdenoise + mpeg2enc -reduce-hf : 4900 kb/s

   * all of the above : 3600 kb/s

   While -reduce-hf or yuvdenoise alone is only a modest improvement,
together they reduce the bitrate substantially.  There is not really
much visible difference between using yuvdenoise alone and yuvdenoise
with mpeg2enc -reduce-hf.

   If you ask yourselve why not alyways use all of the aboth filter ?
Hmmm, hard question. The image softens, and the encoding time increases.
Each filter needs about the same amount of time as mpeg2enc needs for
encoding the video.

   If you have very high quality material and want to keep every detail
you should try to use the mpeg2enc -keep-hf|-h on the other hand

   `Note:' The bitrate reduction you have depends on the material and
on the noise of the images.

* Menu:

* Scaling and offset correction::
* Frame rate conversion::


File: mjpeg-howto.info,  Node: Scaling and offset correction,  Next: Frame rate conversion,  Up: Optimizing the stream

Scaling and offset correction
=============================

   The basic scaling is described in the `Converting video' section

   The scaling, takes a part of the picture, and scales it to a larger
or smaler size. The scaling is done by yuvscaler:

   `lav2yuv test.eli | yuvscaler -I USE_400x400+50+100 | yuvplay'

   Here we only take part of the picture and scale it up to the size of
the original frame.  But yuvscaler also changes the pixel aspect ratio.
That means when you look at the stream using yuvplay it looks like a
square in our example.  After scaling, if the sample (pixel) aspect
ratio were not changed, the video would not display with the proper
aspect ratio.  Yuvscaler compensates by adjusting the sample aspect
ratio.  If you have a interlaced video, the height and HeightOffset
have to be a multiple by 4 if the video is interlaced. Else the values
(width, height, widthoffset, heightoffset) have to be a multiple of 2.

   A other problem that cannot be solved that easy with scaling, is
when the picture is not centered horizontal. On one side you have no
black pixels and on the other you have 30 for example. Scaling is here
is the wrong solution.  y4mshift is the perfect solution because it can
shift the image to the left or right.

   `lav2yuv test.eli | y4mshift -n 20 | mpeg2enc -f 3 -b 4000 -q 10 -o
video.m2v'

   That will shift the image 20 pixels to the right. If you use a
negative the image is shift to the left. You have to use a even number.
The inserted pixels are set to black.

   Some might wonder why the image is not centered and there is a black
border around the image.

   The reason for the black border is the TV (CRT = Catode Ray Tube).
The TV does not show the full picture. A part of the picture is not
shown because the manufacturer cover the edges with a black border.
Because of that border the image is always centered on a TV. But when
you capture the video with a card, you see the whole size of the image
including the border and maybe the offset.

   A horizontal offset is usually not a problem of the capture card. It
is a problem when the film is broadcast and not well synchronized with
the image.  This means that the scan of the source not exactly
synchronized with the carrier signal, you wont see that on TV.


File: mjpeg-howto.info,  Node: Frame rate conversion,  Prev: Scaling and offset correction,  Up: Optimizing the stream

Frame rate conversion
=====================

   Ever needed to convert the framerate from PAL to NTSC or the other
direction around ? Or something much simpler like converting the
framerate from 24FPS to 24000:1001 for conversation from a film frame
rate to a valid NTSC frame rate.

   Than `yuvfps' is your program. It can lower the framerate by dropping
frames, or create a higher framerate by replicating frames. If you have
a wrong framerate in the header you can only change the header of the
YUV stream and not modify the stream.

   Because the frames are only replicated (copied) you should denoise
first and then change the framerate and scale at als last step. If you
have a interlaced source you should also deinterlace before changeing
the framerate. If you create a higher frame rate it is else very likely
that you have weird flickers when you play it back. If you convert PAL
to NTSC (30000:1001 FPS about 29,97 FPS) the frame rate will lower by
about the factor 480/576 (NTSC lines / PAL lines).  Because MPEG's
interframe compression is completely compressing the duplicated frames.
If you lower the frame rate from PAL to NTSC (at 24000:1001) or NTSC
FILM (24FPS) the bitrate will be about (480 Lines * 24 FPS) / (576
Lines * 25FPS).  If you change the frame rate before denoising the
yuvdenoise will have problems finding the noise across the frames, so
the needed bandwith will slightliy increase.

   Example

   `> lav2yuv video.eli | yuvfps -r 30000:1001 | yuvscaler -O SVCD |
mpeg2enc -f 4 -o video_ntsc_svcd.m2v'

   This is a example to convert the source video to a NTSC video
running at 30000:1001 FPS (or about 29,97FPS) at SVCD size.

   Example

   `> lav2yuv video.eli | yuvdenoise -F | yuvfps -r 24000:1001 |
yuvscaler -O SIZE_720x480 | mpeg2enc -f 3 -b 4000 -q 7 -o
video_ntsc.m2v'

   This example shows who you should use the tools. Denoise first and
than change the framerate and in the last step change the image size.

   It can happen that yuvscaler or mpeg2enc do not detect the TV norm
correct. If that happens you have to add the norm option `-n n/p/s' to
the program that chooses the wrong norm.

   If you know that the header tells the wrong framerate, you can
simply change the framerate of the yuv header that way:

   `> lav2yuv video.eli | yuvfps -r 25:1 -c | mpeg2enc -f 3 -b 4000 -q
7 -o video_pal.m2v'

   You need the `-c' option. To tell yuvfps that it only should change
the header of the stream. With the `-r 25:1' you tell yuvfps the frame
rate it should write into the header. In your example the PAL frame
rate of 25 FPS. You always have to use the fractional form.

   If you know that the header is wrong, and you need a other output
bitrate you still can do this in a single step:

   `> lav2yuv video.eli | yuvfps -s 24:1 -r 25:1 | mpeg2enc -o
video.m1v'


File: mjpeg-howto.info,  Node: Transcoding of existing MPEG-2,  Next: Trading Quality/Speed,  Prev: Optimizing the stream,  Up: Top

Transcoding of existing MPEG-2
******************************

   For transcoding existing MPEG-2 streams from digital TV cards or DVD
a lower data-rate than for broadcast will give good results.  Standard
VCD 1152 kbps typically works just fine for MPEG1. The difference is in
the Signal/Noise ratio of the original. The noise in the analog stuff
makes it much harder to compress.

   One other very good guide that helps you transcoding videos can be
found at: http://www.bunkus.org/dvdripping4linux/index.html

   You will also need to manually adjust the audio delay offset
relative to video when multiplexing. Very often around 150ms delay
seems to do the trick.

   You have to download the ac3dec and mpeg2dec packages. You can find
them at mjpeg homepage ( http://sourceforge.net/projects/mjpeg ).  You
also need sox and toolame.

   In the scripts directory there is a `mpegtranscode' script that does
most of the work.

   So transcoding looks like this:

   `> mjpegtranscode -V -o vcd_stream mpeg2src.mpg'

`-V'
     set's the options so that a VCD compatible stream is generated

`-o vcd_stream'
     a vcd_stream.m1v (video) and vcd_stream.mp2 (audio) is created

`mpeg2src.mpg'
     specifies the source stream


   The script prints also something like this:

   `> SYNC 234 mSec'

   You will need to adjust the audio/video startup delays when
multiplexing to ensure audio and video are synchronized.  The exact
delay (in milliseconds) that you need to pass to mplex to synchronize
audio and video using the "-v"" is printed by the extract_ac3 tool
labeled "SYNC" when run with the "s" flag. This is the value th
mjpegtranscode script prints out after the `SYNC' word.

   Then you need to multiplex them like this:

   `> mplex -f 1 -O 234 vcd_stream.mp2 vcd_stream.m1v -o lowrate.mpg'

`-f 1'
     Mux format is set to VCD

`-O 234'
     Video timestamp offset in mSec, generated by the mjpegtranscoding
     script, there negative values are allowed

`vcd_stream.mp2 & vcd_stream.m1v'
     generated files by the script

`lowrate.mpg'
     the VCD compatible output stream


   Here we have a SVCD (MPEG-2 video) example:

   `> mjpegtranscode -S -o svcd_stream mpeg2src.mpg'

   You have to multiplex it with:

   `> mplex -f 4 -O 234 svcd_stream.mp2 svcd_stream.m2v -o lowrate.mpg'

   `Problem:' There is sometimes a problem with NTSC and VCD playback
because movies may be recoded with 3:2 pulldown NTSC with 60
fields/sec. mpeg2dec is designed for playback on computers and
generates the original 24frames/sec bitrate. If you encode the video
now 30frames/sec video is created. This video is now much too short for
the encoded audio.

   The transcoding can be made to work but it must be done manually:

   `> cat mpeg2src.mpg | mpeg2dec -s -o YUVs | mpeg2enc -I 0 -f 4 -q 9
-V 230 -p -P -o svcd_stream.m2v'

   The -p tells mpeg2enc to generate header flags for 3:2 pull down of
24fps movie. It may also work if you do not add the -p flag.  You do
not need the -p flag when transcoding to VCD format because it is not
supported in mpeg1.

* Menu:

* If you want to do every step on your own it has to look like this::


File: mjpeg-howto.info,  Node: If you want to do every step on your own it has to look like this,  Up: Transcoding of existing MPEG-2

If you want to do every step on your own it has to look like this
=================================================================

   Extracting Audio:

   `> cat test2.mpg | extract_ac3 - -s | ac3dec -o wav -p sound.wav
2>/dev/null'

   One of the first lines showed contains the label "SYNC" you have to
use this time afterwards for the multiplexing. The 2>/dev/null
redirects the output of ac3dec to /dev/null.  In the next step you
generate the mpeg audio file:

   `> cat sound.wav | mp2enc -V -v 2 -o audio.mp2'

`-V'
     forces VCD format, the sampling rate is converted to 44.1kHz from
     48kHz

`-v 2'
     unnecessary but if you use it mp2enc tells you how many seconds of
     the audio file are already encoded.

`-o'
     Specifies the output file.


   cat test2.mpg | extract_ac3 - -s | ac3dec -o wav | sox -t wav
/dev/stdin -t wav -r 44100 /dev/stdout | toolame -p 2 -b 224 /dev/stdin
audio.mp2

   This should you command look like when you want to use `toolame'.
One of the first lines again output contains the label "SYNC".  You
have to use this time (referred to as "SYNC_value" below) when doing the
multiplexing.

   You can generate VCD and SVCD videos, and own mpeg1/2 videos.

   For VCD creation use:

   `> cat test2.mpg " mpeg2dec -s -o YUVh " mpeg2enc -s -o
video_vcd.m1v'

`'
     mpeg2dec:

`-s'
     tells mpeg2dec to use program stream demultiplexer

`-o YUVh'
     the output size of the extracted frames.


   There are other output modes, try "mpeg2dec -help" but the most
important here are:

`YUV'
     is the full image size, unscaled

`YUVs'
     is SVCD size, it can only scale down to 2/3 of the original size

`YUVh'
     is VCD size, or about the half of the original size


   Mplex with:

   `> mplex -f 1 -O SYNC_value audio.mp2 video_vcd.m1v -o
vcd_stream.mpg'

`-f 1'
     generates an VCD stream

`-O SYNC_value'
     the value mentioned above


   For SVCD creation use:

   `> cat test2.mpg | mpeg2dec -s -o YUVs | mpeg2enc -f 4 -q 9 -V 230
-o video_svcd.mpg'

`-q 9'
     Quality factor for the stream (VBR stream) (default q: 12)

`-V 230'
     Target video buffer size in KB

`-o'
     Output file


   Mplex with:

   `> mplex -f 4 -b 230 audio.mp2 video_svcd -o svcd_stream.mpg'

`-f 4'
     generate an SVCD stream

`-b 200'
     Specify the video buffer size by the playback device.


   For other video output formats this might work:

   `> cat test2.mpg | mpeg2dec -s -o YUV | yuvscaler -O SIZE_320x200 -O
NOT_INTERLACED | mpeg2enc -o strange_video.m1v'

   If you want to edit mpeg streams, this also works, but in a slightly
different way. For demultiplexing you can use bbdmux, from the bbtools
package. Splits out either video or audio very cleanly.  You can't get
it any more from the homepage from Brent Beyler, it can still be found
when you search for it using that keywords " bbtools linux -suse
-blackbox". Currenty it can be found at: http://www.nop.org/inkling/

   First run:

   `> bbdmux myvideo.mpg'

   You should get something like this:

   Found stream id 0xE0 = Video Stream 0 Found stream id 0xC0 = MPEG
Audio Stream 0 Found stream id 0xBE = Padding Stream

   Extract audio with:

   `> bbdmux myvideo.mpg 0xC0 audio.mp1'

   Convert it to wav:

   `> mpg123 -w audio.wav audio.m1v'

   Extract video with:

   `> bbdmux myvideo.mpg 0xE0 video.m1v'

   Converting video to an mjpeg avi stream:

   `> cat video.m1v | mpeg2dec -o YUV | yuv2lav -f a -o test.avi'

   Then adding the sound to the avi:

   `> lavaddwav test.avi audio.wav final.avi'

   If the source video has already the size of the target video use -o
YUV. Using YUVh makes the video the half size!  The rest can be done
just like editing and encoding other streams.  If you have videos with
ac3 sound you only have to adapt the commands above.

   Extracting Audio:

   `> cat test2.mpg | extract_ac3 - -s | ac3dec -o wav 2>dev/null
>sound.wav'

   Extract video:

   `> cat test2.mpg | mpeg2dec -s -o YUVh | yuv2lav -f a -q 85 -o
test.avi'

   Adding the sound:

   `> lavaddwav test.avi sound.wav fullvideo.avi'

   `NOTE:'You need much disk space. 1GB of video has a size of about 2GB
at SVCD format and of course disk space is needed for some temp files.
Converting the Video to mjpeg also takes some time.  On my Athlon 500 I
never get more than 6-7 Frames a second.  You loose quality each time
you convert a stream into an other format!


File: mjpeg-howto.info,  Node: Trading Quality/Speed,  Next: SMP and distributed Encoding,  Prev: Transcoding of existing MPEG-2,  Up: Top

Trading Quality/Speed
*********************

   If absolute quality is your objective a modest improvement can be
achieved using the -4 and -2 flags.  These control how ruthlessly
mpeg2enc discards bad looking matches between sections of adjacent
frames during the early stages of the search when it is working with
4*4 and 2*2 clusters of pixels rather than individual pixels. Setting
-4 1 -2 1 maximizes quality. -4 4 -2 4 maximizes speed. Note that
because the statistical criteria mpeg2enc uses for discarding bad
looking matches are usually fairly reliable the increase/decrease in
quality is modest (but noticeable).

   Reducing the radius of the search for matching sections of images
also increases speed. However due to the way the search algorithm works
the search radius is in effect rounded to the nearest multiple of 8.
Furthermore, on modern CPU's the speed gained by reducing the radius
below 16 is not large enough to make the marked quality reduction
worthwhile for most applications.

* Menu:

* Creating streams to be played from disk using Software players::


File: mjpeg-howto.info,  Node: Creating streams to be played from disk using Software players,  Up: Trading Quality/Speed

Creating streams to be played from disk using Software players
==============================================================

   Usually MPEG player software is much more flexible than the hardware
built into DVD and VCD players. This flexibility allows for
significantly better compression to be achieved for the same quality.
The trick is to generate video streams that use big video buffers
(500KB or more) and variable bitrate encoding (the -f, -q flag to
mpeg2enc). Software players will often also correctly play back the
much more efficient MPEG layer 3 (yes, "MP3" audio format.  A good Mp3
encoder like lame will produce results comparable to layer 2 at 224Kbps
at 128Kbps or 160Kbps.

