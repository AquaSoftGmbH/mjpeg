/*
 *  Copyright (C) 2001 Kawamata/Hitoshi <hitoshi.kawamata@nifty.ne.jp>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <config.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <mpegtimecode.h>
#include "yuvfilters.h"

#define STILLRATIO(N) ((N)*3/2)
#define NOISERATIO(N) ((N)/8*7)
#define MAXHALFHEIGHT 288
#define NOISEMAX 31
#define NOISEINIT 5

static void
buf_debug(char *buf, FILE *fp, const char *format, ...)
{
  va_list ap;
  va_start(ap, format);
  vsprintf(buf + strlen(buf), format, ap);
  va_end(ap);
  if (buf[strlen(buf) - 1] == '\n') {
    if (fp) {
      fputs(buf, fp);
    } else {
#ifdef MJPEGTOOLS
      mjpeg_debug(buf);
#else
      fputs(buf, stderr);
#endif
    }
    buf[0] = '\0';
  }
}

typedef struct {
  YfTaskCore_t _;
  int fpscode0;
  FILE *cyfp;
  int cytype;
  int nfields;
  int nframes;
  int iget;
  int iuse;
  int iput;
  YfFrame_t *frame;
  union {
    struct {			/* use in 1st try */
      unsigned long dist[NOISEMAX+1];
      unsigned long total;
      unsigned int level;
    } noise;
    struct {			/* use in retry */
      char buff[32];
      char *p;
    } cy;
  } u;
  struct {
    unsigned long odiff;	/* odd field (or non-intarlaced frame) diff */
    unsigned long ediff;	/* even field diff (only when interlaced) */
    long eoediff;		/* previous even - odd - even diff */
    unsigned long diffdist[NOISEMAX+1];
  } framestat[0];
} YfTask_t;

DEFINE_STD_YFTASKCLASS(yuvkineco);
DECLARE_YFTASKCLASS(yuvycsnoise);

static const char *
do_usage()
{
  return "[-S YCSNoiseThreashold] [-F OutputFPSCODE] {[-C OutputCycleListName] | -[ON] InputCycleListName}";
}

static YfTaskCore_t *
do_init(int argc, char **argv, const YfTaskCore_t *h0)
{
  int fpscode;
  int nframes;
  YfTask_t *h;
  int c;
  int cytype = 0;
  char *cyname = NULL;
  char *ycsthres = NULL;
  YfTaskCore_t *hycs = NULL;

  fpscode = h0->fpscode;
  while ((c = getopt(argc, argv, "S:F:C:O:N:")) != -1) {
    switch (c) {
    case 'S':
      ycsthres = optarg;
      break;
    case 'F':
      fpscode = atoi(optarg);
      break;
    case 'C':
    case 'O':
    case 'N':
      cytype = c;
      cyname = optarg;
      break;
    default:
      return NULL;
    }
  }
  if (cytype != 'N' && h0->fpscode != 4 && h0->fpscode != 5) {
    WERROR("unsupported input fps\n");
    return NULL;
  }
  if (fpscode < 1 || h0->fpscode < fpscode) {
    WERROR("illeagal output fpscode\n");
    return NULL;
  }
  if (h0->interlace == Y4M_ILACE_BOTTOM_FIRST) {
    WERROR("unsupported field order\n");
    return NULL;
  }
  if (ycsthres) {
    char ycssopt[] = "-S";
    char *ycsargv[] = { argv[0], ycssopt, ycsthres, NULL, };
    optind = 1;
    if (!(hycs = YfAddNewTask(&yuvycsnoise,
			   (sizeof ycsargv / sizeof ycsargv[0]) - 1,
			   ycsargv, h0)))
      return NULL;
  }
  nframes = ((!cytype || cytype == 'C')? 9: 2);
  h = (YfTask_t *)
    YfAllocateTask(&yuvkineco,
		   (sizeof *h +
		    ((((sizeof h->framestat[0]) * (!cytype || cytype == 'C')) +
		      FRAMEBYTES(h0->width, h0->height)) * nframes)),
		   (hycs? hycs: h0));
  if (!h)
    return NULL;
  h->_.interlace = Y4M_ILACE_NONE;
  h->_.fpscode = fpscode;
  h->fpscode0  = h0->fpscode;
  h->cytype    = cytype;
  h->nfields   = ((h0->interlace == Y4M_UNKNOWN)?
		  (MAXHALFHEIGHT < h0->height): h0->interlace) + 1;
  h->nframes   = nframes;
  h->frame     = (YfFrame_t *)(h->framestat +
			     (nframes * (!cytype || cytype == 'C')));
  h->u.noise.level = NOISEINIT;
  if (!cytype)
    goto RETURN;
  if ((h->cyfp = fopen(cyname, ((cytype == 'C')? "w": "r"))) == NULL) {
    perror(cyname);
    YfFreeTask((YfTaskCore_t *)h);
    return NULL;
  }
  if (cytype == 'C') {
    fprintf(h->cyfp, "# 2-3 pull down cycle list
# Generated by 'yuvkineco%s%s -F %d -C %s'
#
# Each character in list mean how each frame processed:
#  O: Output
#  o: Output but should be drop
#  X: replace bottom field by previous one and output
#  x: replace bottom field by previous one and output but should be drop
#  _: drop
#
# You can edit this list by hand and retry yuvkineco.
# When edit, you can use characters in addtion to above:
#  Z: replace bottom field by previous one and output
#  z: replace bottom field by previous one and output or drop
#  T: duplicate Top field and output
#  t: duplicate Top field and output or drop
#  B: duplicate Bottom field and output
#  b: duplicate Bottom field and output or drop
#
# Use this list with old input to generator yuvkineco,
# do 'yuvkineco -F fpscode -O %s',
# with output new,
# do 'yuvkineco -F fpscode -N %s'.
#
# When used as '-O %s':
#  O:    Output
#  o:    Output or drop
#  X: Z: replace bottom field by previous one and output
#  x: z: replace bottom field by previous one and output or drop
#  _:    drop
#  T:    duplicate Top field and output
#  t:    duplicate Top field and output or drop
#  B:    duplicate Bottom field and output
#  b:    duplicate Bottom field and output or drop
#
# When used as '-N %s':
#  O: X: Output
#  o: x: Output or drop
#  Z:    replace bottom field by previous one and output
#  z:    replace bottom field by previous one and output or drop
#  _:    ignore
#  T:    duplicate Top field and output
#  t:    duplicate Top field and output or drop
#  B:    duplicate Bottom field and output
#  b:    duplicate Bottom field and output or drop
#
SIZE:%dx%d OLD_FPS:%d NEW_FPS:%d # DON'T CHANGE THIS LINE!!!",
	    (ycsthres? " -S ": ""), (ycsthres? ycsthres: ""),
	    fpscode, cyname, cyname, cyname, cyname, cyname,
	    h0->width, h0->height, h0->fpscode, fpscode);
  } else {
    int width, height, oldfps, newfps;
    char buff[128];

    h->u.cy.p = h->u.cy.buff;
    buff[sizeof buff - 1] = buff[sizeof buff - 2] = '\0';
    while (fgets(buff, sizeof buff, h->cyfp)) {
      if (sscanf(buff, "SIZE:%dx%d OLD_FPS:%d NEW_FPS:%d ",
		 &width, &height, &oldfps, &newfps) == 4) {
	if (width != h0->width || height != h0->height ||
	    ((h->cytype == 'O')? oldfps: newfps) != h0->fpscode) {
	  WERROR("input and cycle list not match.\n");
	  goto ERROR;
	}
	if (h->cytype == 'O' && newfps < fpscode) {
	  WERROR("output fpscode greater than specified at 1st try.\n");
	  goto ERROR;
	}
	goto RETURN;
      }
    }
    WERROR("broken cycle list.\n");
  ERROR:
    fclose(h->cyfp);
    YfFreeTask((YfTaskCore_t *)h);
    return NULL;
  }
 RETURN:
  return (YfTaskCore_t *)h;
}

static void
dumpnoise(YfTask_t *h, FILE *fp)
{
  int i;
  char buf[256];
  if (!h->u.noise.total)
    return;
  buf[0] = '\0';
  buf_debug(buf, fp, "#\n");
  buf_debug(buf, fp, "# noise level: %u (# of sample: %lu);  noise distribution:\n",
	    h->u.noise.level, h->u.noise.total);
  buf_debug(buf, fp, "#");
  for (i = 0; i <= NOISEMAX; i++)
    buf_debug(buf, fp, " %lu",
	      (unsigned long)((((unsigned long long)h->u.noise.dist[i] * 1000) +
			       h->u.noise.total - 1) / h->u.noise.total));
  buf_debug(buf, fp, "\n");
}

static void
do_fini(YfTaskCore_t *handle)
{
  YfTask_t *h = (YfTask_t *)handle;
  while (h->iuse < h->iget)
    do_frame((YfTaskCore_t *)h, NULL, NULL);
  if (1 < verbose)
    dumpnoise(h, NULL);
  if (h->cytype == 'C') {
    putc('\n', h->cyfp);
    dumpnoise(h, h->cyfp);
    fclose(h->cyfp);
  }
  YfFreeTask((YfTaskCore_t *)h);
}

static void
putcy(YfTask_t *h, int c)
{
  MPEG_timecode_t tc;
  int f;
  f = mpeg_timecode(&tc, h->iuse, h->fpscode0, 0.);
  if (f <= 0) {
    putc('\n', h->cyfp);
    if (tc.s == 0) {
      if (tc.m % 10 == 0)
	dumpnoise(h, h->cyfp);
      fputs("#
#    OLD                NEW            0.... 5.... 10....15.... 20....25....
",
	    h->cyfp);
    }
    fprintf(h->cyfp, "%06d/%02d:%02d:%02d:%02d ", h->iuse, tc.h, tc.m, tc.s, tc.f);
    mpeg_timecode(&tc, h->iput, h->_.fpscode, 0.);
    fprintf(h->cyfp, "%06d/%02d:%02d:%02d:%02d", h->iput, tc.h, tc.m, tc.s, tc.f);
  }
  if (f < 0) {
    int i;
    f = -f;
    for (i = -1; i <= f; i++)
      putc(' ', h->cyfp);
  }
  if (f % 10 == 0)
    putc(' ', h->cyfp);
  if (f %  5 == 0)
    putc(' ', h->cyfp);
  if (c != '_' &&
      h->framestat[h->iuse % h->nframes].eoediff == 99999999)
    c += 'X' - 'O';
  putc(c, h->cyfp);
}

static int
do_frame(YfTaskCore_t *handle, const YfTaskCore_t *h0, const YfFrame_t *frame0)
{
  static const unsigned long fp1001s[] = {
    0, 24000, 24024, 25025, 30000, 30030, 50050, 60000, 60060, };
  YfTask_t *h = (YfTask_t *)handle;
  int framebytes = FRAMEBYTES(h->_.width, h->_.height);
  int iadjust = ((h->_.fpscode == h->fpscode0)? 1:
		 ((h->iuse * fp1001s[h->_.fpscode] /
		   fp1001s[h->fpscode0]) - h->iput));

    /* copy frame to buffer */
  if (frame0) {
    int b = h->iget % h->nframes;
    YfFrame_t *fget = (YfFrame_t *)((char *)h->frame + (b * framebytes));
    memcpy(fget, frame0, framebytes);
    /* get frame summary */
    if (h->cytype == 'O' || h->cytype =='N') {
      /* do nothing */
    } else if (!h->iget) {
      h->framestat[b].odiff = 9999999;
    } else {
      int i, j, d;
      unsigned int ypre, yget, noise;
      int ipre = (h->iget - 1) % h->nframes;
      YfFrame_t *fpre = (YfFrame_t *)((char *)h->frame + (ipre * framebytes));
      memset(&h->framestat[b], 0, sizeof h->framestat[b]);
      for (i = h->nfields; i < h->_.height; i += h->nfields) {
	for (j = 0; j < h->_.width; j++) {
	  ypre = fpre->data[(i * h->_.width) + j];
	  yget = fget->data[(i * h->_.width) + j];
	  noise = h->u.noise.level;
	  if (yget < noise)
	    noise = yget;
	  else if (256 - yget < noise)
	    noise = 256 - yget;
	  if ((d = ypre - yget) < 0) d = -d;
	  h->framestat[b].diffdist[(d < NOISEMAX)? d: NOISEMAX]++;
	  if (noise < d) {
	    d -= noise;
	    h->framestat[b].odiff += (((d * d) + 8) >> 4);
	  }
	  if (1 < h->nfields) {
	    unsigned int ygte;
	    ypre = fpre->data[((i - 1) * h->_.width) + j];
	    ygte = fget->data[((i - 1) * h->_.width) + j];
	    if ((d = yget - ygte) < 0) d = -d;
	    if (noise < d) {
	      d -= noise;
	      h->framestat[b].eoediff -= (((d * d) + 16) >> 5);
	    }
	    if ((d = yget - ypre) < 0) d = -d;
	    if (noise < d) {
	      d -= noise;
	      h->framestat[b].eoediff += (((d * d) + 16) >> 5);
	    }
	    ypre = fpre->data[((i + 1) * h->_.width) + j];
	    ygte = fget->data[((i + 1) * h->_.width) + j];
	    if ((d = yget - ygte) < 0) d = -d;
	    if (noise < d) {
	      d -= noise;
	      h->framestat[b].eoediff -= (((d * d) + 16) >> 5);
	    }
	    if ((d = yget - ypre) < 0) d = -d;
	    if (noise < d) {
	      d -= noise;
	      h->framestat[b].eoediff += (((d * d) + 16) >> 5);
	    }
	    if ((d = ypre - ygte) < 0) d = -d;
	    if (noise < d) {
	      d -= noise;
	      h->framestat[b].ediff += (((d * d) + 8) >> 4);
	    }
	  }
	}
      }
#define PER1024PIXEL(p,h,w) (((p)/=(w)), ((p)<<=10), ((p)/=(h)))
      PER1024PIXEL(h->framestat[b].odiff, ((h->_.height / h->nfields) - 1), h->_.width);
      if (1 < h->nfields) {
	PER1024PIXEL(h->framestat[b].ediff, ((h->_.height / 2) - 1), h->_.width);
	PER1024PIXEL(h->framestat[b].eoediff, ((h->_.height / 2) - 1), h->_.width);
      }
    }
    h->iget++;
  }

  if (!h->cytype || h->cytype =='C') { /* 1st try */
    /* process frames in buffer */
    if (h->iget - h->iuse == h->nframes || !frame0) {
      int b = h->iuse % h->nframes;
      int i, imin = -1, i2nd = -1;
      unsigned long dmin = 0xffffffffUL, d2nd = 0xffffffffUL, d3rd = 0xffffffffUL;
      char debugbuf[256];
      debugbuf[0] = '\0';
      if (1 < verbose) {
	buf_debug(debugbuf, NULL, "%5d%5d ", h->iuse, h->iput);
	if (0 < iadjust)
	  buf_debug(debugbuf, NULL, "%8s:%-7s", "-", "-");
      }

      /* search still frame (min diff) */
      for (i = (0 < iadjust); i < h->iget - h->iuse - (h->nframes / 4) + 1; i++) {
	unsigned long odiff = h->framestat[(b + i) % h->nframes].odiff;
	if (1 < verbose)
	  buf_debug(debugbuf, NULL, "%8ld:%-7lu",
		    h->framestat[(b + i) % h->nframes].eoediff, odiff);
	if (odiff < dmin) {
	  d3rd = d2nd;
	  d2nd = dmin;
	  dmin = odiff;
	  i2nd = imin;
	  imin = i;
	} else if (odiff < d2nd) {
	  d3rd = d2nd;
	  d2nd = odiff;
	  i2nd = i;
	} else if (odiff < d3rd) {
	  d3rd = odiff;
	}
      }
      if (i2nd < imin && d2nd <= STILLRATIO(dmin)) /* 2 found, select earlier */
	imin = i2nd;
      if (d3rd == 0xffffffffUL) {	/* at EOF, only a few frames in buffer */
	d3rd = d2nd;
	if (imin < 0)
	  imin = h->iget - h->iuse - 1;
      } else if (STILLRATIO(dmin) < d3rd) { /* ensure still frame */
	/* apply frame summary */
	unsigned long noisetotal;
	int bmin;
	int diff1024;
	while ((noisetotal = (h->u.noise.total +
			      (((h->_.height / h->nfields) - 1) * h->_.width))) <
	       h->u.noise.total)	/* overflow */
	  for (h->u.noise.total = 0, i = 0; i <= NOISEMAX; i++)
	    h->u.noise.total += (h->u.noise.dist[i] >>= 1);
	h->u.noise.total = noisetotal;
	bmin = (b + imin) % h->nframes;
	for (i = 0; i <= NOISEMAX; i++)
	  h->u.noise.dist[i] += h->framestat[bmin].diffdist[i];
	noisetotal = NOISERATIO(noisetotal);
	for (i = 0; i <= NOISEMAX; i++) {
	  if (noisetotal < h->u.noise.dist[i])
	    break;
	  noisetotal -= h->u.noise.dist[i];
	}
	diff1024 = (i - h->u.noise.level) * 1024;
	h->u.noise.level = i;
	if (diff1024) {
	  for (i = 0; i < h->nframes; i++) {
	    if (diff1024 < -(int)h->framestat[i].odiff)
	      h->framestat[i].odiff = 0;
	    else
	      h->framestat[i].odiff += diff1024;
	  }
	  if (1 < h->nfields)
	    for (i = 0; i < h->nframes; i++) {
	      if (diff1024 < -(int)h->framestat[i].ediff)
		h->framestat[i].ediff = 0;
	      else
		h->framestat[i].ediff += diff1024;
	    }
	}
      } else {
	imin = h->nframes / 2;
	if (h->iget - h->iuse < imin)
	  imin = h->iget - h->iuse;
	while ((0 < iadjust) < imin &&
	       STILLRATIO(dmin) < h->framestat[(b + imin) % h->nframes].odiff)
	  imin--;
      }
      if (1 < verbose)
	buf_debug(debugbuf, NULL, "%3d%3d%8lu%8lu%4lu", iadjust, imin, d3rd, dmin,
		  (dmin? (d3rd / STILLRATIO(dmin)): 9999));

      /* search frames field merged */
      if (1 < h->nfields) {
	int j;
	int ifld[12];
	long dfld[12];
	memset(ifld, -1, sizeof ifld);
	dfld[0] = -STILLRATIO(dmin); /* search negative (not near 0) eoediff */
	for (j = 1; j < sizeof dfld / sizeof dfld[0]; j++)
	  dfld[j] = dfld[0];
	for (i = h->nframes / 4; i < h->iget - h->iuse - (h->nframes / 4); i++) {
	  long eoediff = h->framestat[(b + i) % h->nframes].eoediff;
	  for (j = 0; j <= i - (h->nframes / 4); j++) {
	    if (eoediff < dfld[j]) {
	      int j1;
	      for (j1 = i - (h->nframes / 4); j < j1; --j1) {
		dfld[j1] = dfld[j1 - 1];
		ifld[j1] = ifld[j1 - 1];
	      }
	      dfld[j] = eoediff;
	      ifld[j] = i;
	      break;
	    }
	  }
	}
	i = h->nframes;
	for (j = h->nframes / 2; 0 <= --j;)
	  if (0 <= ifld[j] && ifld[j] < i)
	    i = ifld[j];
	if (i < imin)
	  imin = i;
      }
      if (1 < verbose)
	buf_debug(debugbuf, NULL, "%2d", imin);

      /* reconstruct frame field merged */
      if (1 < h->nfields) {
	int isrc, isrc0;
	isrc0 = ((0 < iadjust && 0 < imin)? (imin - 1): imin);
	isrc = imin + (h->nframes / 4) - 1;
	if (h->iget - h->iuse - 2 < isrc)
	  isrc = h->iget - h->iuse - 2;
	for (; isrc0 <= isrc; --isrc) {
	  int bsrc = (b + isrc) % h->nframes;
	  int bdst = (bsrc + 1) % h->nframes;
	  if ((isrc < imin + (h->nframes / 4) - 1 ||
	       STILLRATIO(dmin) < h->framestat[bdst].ediff) &&
	      h->framestat[bdst].eoediff <= 0) {
	    YfFrame_t *fsrc = (YfFrame_t *)((char *)h->frame + (bsrc * framebytes));
	    YfFrame_t *fdst = (YfFrame_t *)((char *)h->frame + (bdst * framebytes));
	    for (i = 1; i < h->_.height; i += 2) /* copy bottom field Y */
	      memcpy(&fdst->data[i * h->_.width],
		     &fsrc->data[i * h->_.width], h->_.width);
	    for (i = (h->_.height * 2) + 1; i < h->_.height * 3; i += 2) /* UV */
	      memcpy(&fdst->data[i * h->_.width / 2],
		     &fsrc->data[i * h->_.width / 2],
		     h->_.width / 2);
	    if (1 < verbose)
	      buf_debug(debugbuf, NULL, "%2d", isrc + 1);
	    h->framestat[bdst].eoediff = 99999999;
	  } else {
	    if (1 < verbose)
	      buf_debug(debugbuf, NULL, " -");
	  }
	}
      }
      if (1 < verbose)
	buf_debug(debugbuf, NULL, "\n");

      /* output frames */
      for (i = 0; i < imin; i++) {
	int ret;
	if (h->cytype == 'C')
	  putcy(h, 'O');
	if ((ret = YfPutFrame(&h->_, (YfFrame_t *)((char *)h->frame +
						   (b * framebytes)))))
	  return ret;
	h->iput++;
	h->iuse++;
	b = h->iuse % h->nframes;
      }
      if (h->iuse < h->iget) {
	if (iadjust <= 0) {
	  if (h->cytype == 'C')
	    putcy(h, '_');
	} else {
	  int ret;
	  if (h->cytype == 'C')
	    putcy(h, 'o');
	  if ((ret = YfPutFrame(&h->_, (YfFrame_t *)((char *)h->frame +
						     (b * framebytes)))))
	    return ret;
	  h->iput++;
	}
	h->iuse++;
      }
    }
  } else {			/* retry */
    int i, c;
    YfFrame_t *fsrc, *fdst;
    while (!*h->u.cy.p) {
      char *s, *d;
      char buff[128];
      d = h->u.cy.p = h->u.cy.buff;
      if (!fgets(buff, sizeof buff, h->cyfp)) {
	perror("cycle list");
	return 1;
      }
      for (s = buff; (c = *s); s++) { /* FIXME: frame# should be checked */
	if (c == '#')
	  break;
	if (isalpha(c) || (c == '_' && h->cytype == 'O')) {
	  if (h->u.cy.buff + 30 <= d) {
	    WWARN("too long line in cycle list.\n");
	    break;
	  }
	  *d++ = c;
	}
      }
      *d = '\0';
    }
    fsrc = (YfFrame_t *)((char *)h->frame + (((h->iuse - 1) % h->nframes) * framebytes));
    fdst = (YfFrame_t *)((char *)h->frame + (((h->iuse)     % h->nframes) * framebytes));
    h->iuse++;
    c = *h->u.cy.p++;
    if (c == '_')
      return 0;
    if (islower(c)) {
      if (iadjust <= 0)
	return 0;
      c += 'A' - 'a';
    }
    i = 0;
    switch (c) {
    case 'X':
      if (h->cytype == 'N')
	break;
    case 'Z':
      for (i = 1; i < h->_.height; i += 2) /* copy bottom field Y */
	memcpy(&fdst->data[i * h->_.width],
	       &fsrc->data[i * h->_.width], h->_.width);
      for (i = (h->_.height * 2) + 1; i < h->_.height * 3; i += 2) /* UV */
	memcpy(&fdst->data[i * h->_.width / 2],
	       &fsrc->data[i * h->_.width / 2],
	       h->_.width / 2);
      break;
    case 'T':
      for (i = 0; i < h->_.height; i += 2) /* duplicate top field Y */
	memcpy(&fdst->data[(i + 1) * h->_.width],
	       &fdst->data[(i)     * h->_.width], h->_.width);
      for (i = (h->_.height * 2); i < h->_.height * 3; i += 2) /* UV */
	memcpy(&fdst->data[(i + 1) * h->_.width / 2],
	       &fdst->data[(i)     * h->_.width / 2],
	       h->_.width / 2);
      break;
    case 'B':
      for (i = 0; i < h->_.height; i += 2) /* duplicate bottom field Y */
	memcpy(&fdst->data[(i)     * h->_.width],
	       &fdst->data[(i + 1) * h->_.width], h->_.width);
      for (i = (h->_.height * 2); i < h->_.height * 3; i += 2) /* UV */
	memcpy(&fdst->data[(i)     * h->_.width / 2],
	       &fdst->data[(i + 1) * h->_.width / 2],
	       h->_.width / 2);
      break;
    }
    if ((c = YfPutFrame(&h->_, fdst)))
      return c;
    h->iput++;
    if (i)
      memcpy(fdst, frame0, framebytes);
  }
  return 0;
}
